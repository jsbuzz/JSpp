<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<title>js++ demo</title>
	
	<style type="text/css">
		* {
			font-family: Calibri,Helvetia,sans-serif;
		}

		body {
			padding:20px;
			margin:0;
		}
	</style>

	<script type="text/javascript" src="../js++.js"></script>
	<script type="text/javascript">

	_DEBUG = false;
	
	
	// A very extreme example of using the super() method from the constructor

/*
 Interesting note, that the private getter/setter doesn't work with the super() method because it will always refer to the
 A._instance instead of the current one. It is because of the declaration scope.
 
 So this current version [1.0 | 2012-10-11] doesn't support the private setters and getters with the super() method.
 
 But the ugly method pair getPrivate/setPrivate works fine for the same reason.
*/

	/**
	* class A
	*/
	var A = Class(function(a){
			_DEBUG && console.info('A::constructor('+Array.prototype.join.call(arguments)+')');
			
			var private_a=2;
			
			this.setMyVariables = function(a){
				_DEBUG && console.info('	A::setMyVariables('+Array.prototype.join.call(arguments)+')');
				this.a = a;
				this.setPrivate('a',a);
			};
			
			this.getPrivate = function(varName){
				return eval('(private_'+varName+')');
			};
			
			this.setPrivate = function(varName,value){
				return eval('private_'+varName+'='+value);
			};
			
			if(a!==undefined)
				this.setMyVariables(a);
	});

	/**
	* class B : A
	* -> A::constructor ()
	*/
	var B = A.derived(function(a,b){
			_DEBUG && console.info('B::constructor('+Array.prototype.join.call(arguments)+')');
			
			this.setMyVariables = function(a,b){
				_DEBUG && console.info('	B::setMyVariables('+Array.prototype.join.call(arguments)+')');
				this.super('setMyVariables',a);
				this.b = b;
			};
			
			if(a!==undefined)
				this.setMyVariables(a,b);
	},"(a,b)=>A()");



	/**
	* class C : B
	* -> B::constructor ()
	*/
	var C = B.derived(function(a,b,c){
			_DEBUG && console.info('C::constructor('+Array.prototype.join.call(arguments)+')');
			
			this.setMyVariables = function(a,b,c){
				_DEBUG && console.info('	C::setMyVariables('+Array.prototype.join.call(arguments)+')');
				this.super('setMyVariables',a,b);
				this.c = c;
			};
			
			if(a!==undefined)
				this.setMyVariables(a,b,c);
	},"(a,b,c)=>B()");


	// extend showOff :)
	A.extend({
		showMe : function(){console.info(this)}
	},true);

	function loadTest()
	{
		_DEBUG = true;
		console.info('# First there will be a lot of constructor calls as the instances are initialized for the classes');
		c = new C(1,2,3);
		c.showMe();
		
		_DEBUG = true;
		console.info('# The second time is less messy');
		console.info('# it is easier to see the process step by step');
		c = new C(1,2,3);
		c.showMe();
	}
	</script>

</head>

<body onload="loadTest()">
</body>
</html>